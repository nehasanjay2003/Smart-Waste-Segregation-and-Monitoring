# -*- coding: utf-8 -*-
"""Smart Garbage new

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WeAmEUb3pL2xT3bizWh27ity9Cf7Z5cW
"""

# 1. Upload your kaggle.json API token
from google.colab import files
files.upload()

# 2. Move the token to the right place
!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

# 3. Install Kaggle Python package (if not already installed)
!pip install kaggle

# 4. Download the dataset from Kaggle
!kaggle datasets download -d mostafaabla/garbage-classification

# 5. Unzip the downloaded dataset
!unzip garbage-classification.zip -d garbage_dataset

# 6. List the contents to verify
!ls garbage_dataset

dataset_path = "/content/garbage_dataset/garbage_classification"

from tensorflow.keras.preprocessing.image import ImageDataGenerator

datagen = ImageDataGenerator(validation_split=0.2)

train_gen = datagen.flow_from_directory(
    dataset_path,
    target_size=(224, 224),
    batch_size=32,
    class_mode='categorical',
    subset='training'
)

val_gen = datagen.flow_from_directory(
    dataset_path,
    target_size=(224, 224),
    batch_size=32,
    class_mode='categorical',
    subset='validation'
)

num_classes = train_gen.num_classes
num_classes

from google.colab import files
files.download("/content/waste_classifier_mobilenetv2.h5")

import os

base_path = "/content/garbage_dataset/garbage_classification"

for cls in os.listdir(base_path):
    class_path = os.path.join(base_path, cls)
    print(cls, len(os.listdir(class_path)))

import shutil
from sklearn.model_selection import train_test_split

source_dir = "/content/garbage_dataset/garbage_classification"
base_dir = "/content/garbage_dataset/split_dataset"

train_dir = os.path.join(base_dir, "train")
val_dir = os.path.join(base_dir, "val")
test_dir = os.path.join(base_dir, "test")

# Create folders
for folder in [train_dir, val_dir, test_dir]:
    os.makedirs(folder, exist_ok=True)

# Loop through each class folder
for cls in os.listdir(source_dir):
    cls_path = os.path.join(source_dir, cls)

    if os.path.isdir(cls_path):

        images = os.listdir(cls_path)

        train_imgs, temp_imgs = train_test_split(images, test_size=0.2, random_state=42)
        val_imgs, test_imgs = train_test_split(temp_imgs, test_size=0.5, random_state=42)

        # Make class folders
        os.makedirs(os.path.join(train_dir, cls), exist_ok=True)
        os.makedirs(os.path.join(val_dir, cls), exist_ok=True)
        os.makedirs(os.path.join(test_dir, cls), exist_ok=True)

        # Copy images
        for img in train_imgs:
            shutil.copy(os.path.join(cls_path, img), os.path.join(train_dir, cls))

        for img in val_imgs:
            shutil.copy(os.path.join(cls_path, img), os.path.join(val_dir, cls))

        for img in test_imgs:
            shutil.copy(os.path.join(cls_path, img), os.path.join(test_dir, cls))

print("‚úÖ Dataset split into train / val / test successfully!")

from tensorflow.keras.preprocessing.image import ImageDataGenerator

train_datagen = ImageDataGenerator(
    rescale=1./255,
    rotation_range=20,
    zoom_range=0.2,
    width_shift_range=0.1,
    height_shift_range=0.1,
    horizontal_flip=True
)

test_datagen = ImageDataGenerator(rescale=1./255)

train_dir = "/content/garbage_dataset/split_dataset/train"
val_dir = "/content/garbage_dataset/split_dataset/val"
test_dir = "/content/garbage_dataset/split_dataset/test"

train_generator = train_datagen.flow_from_directory(
    train_dir,
    target_size=(224, 224),
    batch_size=32,
    class_mode='categorical'
)

val_generator = test_datagen.flow_from_directory(
    val_dir,
    target_size=(224, 224),
    batch_size=32,
    class_mode='categorical'
)

test_generator = test_datagen.flow_from_directory(
    test_dir,
    target_size=(224, 224),
    batch_size=32,
    class_mode='categorical',
    shuffle=False
)

from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.layers import Dense, GlobalAveragePooling2D
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam

base_model = MobileNetV2(weights='imagenet', include_top=False, input_shape=(224,224,3))
base_model.trainable = False   # Freeze weights

x = base_model.output
x = GlobalAveragePooling2D()(x)
x = Dense(256, activation="relu")(x)
x = Dense(train_generator.num_classes, activation="softmax")(x)

model = Model(inputs=base_model.input, outputs=x)
model.compile(optimizer=Adam(1e-4), loss="categorical_crossentropy", metrics=["accuracy"])

model.summary()

history = model.fit(
    train_generator,
    validation_data=val_generator,
    epochs=10
)

model.save("waste_classifier_mobilenetv2.h5")

from google.colab import files
files.download("waste_classifier_mobilenetv2.h5")

from tensorflow.keras.models import load_model

model = load_model("waste_classifier_mobilenetv2.h5")
print("Model loaded successfully!")

from google.colab import files
uploaded = files.upload()
import numpy as np
from tensorflow.keras.preprocessing import image

filename = list(uploaded.keys())[0]
print("Predicting:", filename)

img = image.load_img(filename, target_size=(224, 224))
img_array = image.img_to_array(img)
img_array = np.expand_dims(img_array, axis=0)
img_array = img_array / 255.0   # normalize

pred = model.predict(img_array)
predicted_class = np.argmax(pred)

class_labels = list(train_generator.class_indices.keys())
print("Detected Class:", class_labels[predicted_class])

RECYCLABLE = [
    'plastic',
    'metal',
    'paper',
    'cardboard',
    'green-glass',
    'brown-glass',
    'white-glass'
]

NON_RECYCLABLE = [
    'biological',   # food waste, organic
    'trash',        # mixed/general waste
    'batteries',    # hazardous
    'clothes',      # usually donated, not recycled in bins
    'shoes'         # same as clothes
]

def get_bin_type(predicted_class):
    if predicted_class in RECYCLABLE:
        return "RECYCLABLE"
    else:
        return "NON_RECYCLABLE"

# -------------------------------
# SMART BIN CLASS (TWO COMPARTMENTS + VISUAL LEVEL)
# -------------------------------

MAX_LEVEL = 90
WARNING_LEVEL = 70

class SmartBin:
    def __init__(self):
        self.recyclable_level = 0
        self.non_recyclable_level = 0

    # Calculate increment based on weight
    def calculate_increment(self, weight_grams):
        if weight_grams <= 50:
            return 10
        elif weight_grams <= 200:
            return 20
        else:
            return 30

    # Simulated SMS
    def send_sms(self, message):
        print(f"üì© [SIMULATED SMS] {message}")

    # Screen alert for users
    def screen_alert(self, message):
        print(f"üñ•Ô∏è [BIN SCREEN ALERT] {message}")

    # Display visual bin levels
    def display_bin_levels(self):
        # Create a bar of 20 characters for each bin
        bar_length = 20
        rec_fill = int((self.recyclable_level / MAX_LEVEL) * bar_length)
        nonrec_fill = int((self.non_recyclable_level / MAX_LEVEL) * bar_length)

        rec_bar = "‚ñà" * rec_fill + "-" * (bar_length - rec_fill)
        nonrec_bar = "‚ñà" * nonrec_fill + "-" * (bar_length - nonrec_fill)

        print("\nüìä BIN LEVELS VISUALIZATION")
        print(f"Recyclable    |{rec_bar}| {self.recyclable_level}%")
        print(f"Non-Recyclable|{nonrec_bar}| {self.non_recyclable_level}%\n")

    # Update bin compartment
    def update_bin(self, bin_type, weight_grams):
        bin_type = bin_type.upper()
        increment = self.calculate_increment(weight_grams)

        # Stop if bin full
        if bin_type == "RECYCLABLE" and self.recyclable_level >= MAX_LEVEL:
            self.screen_alert("üî¥ Recyclable Bin FULL. Please wait!")
            return
        if bin_type == "NON-RECYCLABLE" and self.non_recyclable_level >= MAX_LEVEL:
            self.screen_alert("üî¥ Non-Recyclable Bin FULL. Please wait!")
            return

        # Open compartment and update
        if bin_type == "RECYCLABLE":
            print(f"üü¢ Recyclable Compartment Opened (+{increment}% for {weight_grams}g)")
            self.recyclable_level += increment
            if self.recyclable_level > MAX_LEVEL:
                self.recyclable_level = MAX_LEVEL
        else:
            print(f"üî¥ Non-Recyclable Compartment Opened (+{increment}% for {weight_grams}g)")
            self.non_recyclable_level += increment
            if self.non_recyclable_level > MAX_LEVEL:
                self.non_recyclable_level = MAX_LEVEL

        # Display visual levels
        self.display_bin_levels()

        # Warning alerts
        if self.recyclable_level >= WARNING_LEVEL and self.recyclable_level < MAX_LEVEL:
            self.screen_alert("üü° Recyclable Bin Almost Full!")
            self.send_sms("üîî Warning: Recyclable Bin Almost Full!")

        if self.non_recyclable_level >= WARNING_LEVEL and self.non_recyclable_level < MAX_LEVEL:
            self.screen_alert("üü° Non-Recyclable Bin Almost Full!")
            self.send_sms("üîî Warning: Non-Recyclable Bin Almost Full!")

        # Full alerts
        if self.recyclable_level >= MAX_LEVEL:
            self.screen_alert("üî¥ Recyclable Bin FULL! Wait for emptying.")
            self.send_sms("‚ö† ALERT: Recyclable Bin is FULL! Notify Municipality!")

        if self.non_recyclable_level >= MAX_LEVEL:
            self.screen_alert("üî¥ Non-Recyclable Bin FULL! Wait for emptying.")
            self.send_sms("‚ö† ALERT: Non-Recyclable Bin is FULL! Notify Municipality!")

    # Reset bin compartment
    def reset_bin(self, bin_type):
        bin_type = bin_type.upper()
        if bin_type == "RECYCLABLE":
            self.recyclable_level = 0
            self.screen_alert("‚úÖ Recyclable Bin RESET. You can add garbage now.")
        elif bin_type == "NON-RECYCLABLE":
            self.non_recyclable_level = 0
            self.screen_alert("‚úÖ Non-Recyclable Bin RESET. You can add garbage now.")
        else:
            self.screen_alert(f"‚ùå Invalid bin type '{bin_type}' for reset.")

bin_type = get_bin_type(predicted_class)
print("Send to:", bin_type)
update_bin(bin_type,weight_grams=30)

